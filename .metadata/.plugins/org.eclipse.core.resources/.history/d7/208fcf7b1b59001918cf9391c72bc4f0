#ifndef __LIBRARIES_MOTOR_DRIVER_H__
#define __LIBRARIES_MOTOR_DRIVER_H__

#include <array>
#include <type_traits>
#include <cstring>

#ifdef STM32F0
#include "stm32f0xx.h"
#ifdef USE_STDPERIPH_DRIVER
#include "stm32f0xx_conf.h"
#endif
#endif

#include "can.hpp"

#ifdef STM32F3
#include "stm32f30x.h"
#ifdef USE_STDPERIPH_DRIVER
#include "stm32f30x_conf.h"
#endif
#endif

#ifdef STM32F4
#include "stm32f4xx.h"
#ifdef USE_STDPERIPH_DRIVER
#include "stm32f4xx_conf.h"
#endif
#endif

class MotorDriver
{
public:
	struct SendParamsType
	{
		float PIDgain_P		= 0.0;
		float PIDgain_I		= 0.0;
		float PIDgain_D		= 0.0;
		uint32_t SpeedMAX	= UINT32_MAX;
		uint32_t PPR		= 0;
	};

	MotorDriver() = delete;
	MotorDriver(const uint8_t DriverAddress, const SendParamsType& SetDriverParams) : usingMotorDriverAddress_(DriverAddress)
	{
		this->sendParams_ = SetDriverParams;
	}
	MotorDriver(uint8_t DriverAddress) : usingMotorDriverAddress_(DriverAddress){}

	enum MotorDriveMode : uint8_t
	{
		Stop		= 0x80,
		DutyControl	= 0x00,
		PID			= 0x01
	};
	inline void SetMotorDriveMode(MotorDriveMode SetMode)
	{
		this->nowMode_ = SetMode;
	}
	void SetSpeed(int32_t Speed);
	inline void SetSpeed(int32_t Speed, MotorDriveMode DriveMode)
	{
		SetMotorDriveMode(DriveMode);
		SetSpeed(Speed);
	}

	virtual void update()
	{
		ParamSendTable();
	}

	enum ParamSendMode : uint8_t
	{
		PIDgain_P	= 0x02,
		PIDgain_I	= 0x03,
		PIDgain_D	= 0x04,
		SpeedMAX	= 0x05,
		PPR			= 0x06
	};

	template<ParamSendMode SendMode>
	int8_t MD_ParamSend(const float SendParam)
	{
		static_assert(SendMode == PIDgain_P || SendMode == PIDgain_I || SendMode == PIDgain_D);

		uint32_t SendParam_Converted = BitsConvertion<uint32_t>(SendParam);
		std::array<uint8_t, motorDriverDataArraySize_> SendData = {};

		if constexpr(SendMode == PIDgain_P)	sendParams_.PIDgain_P	= SendParam;
		if constexpr(SendMode == PIDgain_I)	sendParams_.PIDgain_I	= SendParam;
		if constexpr(SendMode == PIDgain_D)	sendParams_.PIDgain_D	= SendParam;

		if(ParamsSendFlag)return -1;

		SendData[0] = SendMode;
		for(std::size_t i = 0 ; i != (SendData.size() - 1) ; ++i)
			SendData[i+1] = (uint8_t)(SendParam_Converted >> 8 * (SendData.size() - (i+1)));

		ControlAreaNetwork::SendData(SendData, usingMotorDriverAddress_);

		return 0;
	}

	template<ParamSendMode SendMode>
	int8_t MD_ParamSend(const uint32_t SendParam)
	{
		static_assert(SendMode == SpeedMAX || SendMode == PPR);

		std::array<uint8_t, motorDriverDataArraySize_> SendData = {};

		if constexpr (SendMode == SpeedMAX)	sendParams_.SpeedMAX	= SendParam;
		if constexpr (SendMode == PPR)		sendParams_.PPR			= SendParam;

		if(ParamsSendFlag)return -1;

		SendData[0] = SendMode;
		for(std::size_t i = 0 ; (SendData.size() - 1) > i ; i++)
			SendData[i+1] = (uint8_t)(SendParam >> 8 * (SendData.size() - (i+1)));

		ControlAreaNetwork::SendData(SendData, usingMotorDriverAddress_);


		return 0;
	}
	inline void MD_ParamSend(const SendParamsType& SetDriverParams)
	{
		sendParams_ = SetDriverParams;
		ParamsSendFlag = true;
	}

	virtual ~MotorDriver(){}

private:
	const uint8_t usingMotorDriverAddress_;

	SendParamsType sendParams_;

	MotorDriveMode nowMode_ = MotorDriveMode::Stop;

	static constexpr size_t motorDriverDataArraySize_ = 5;

	template<class T, class U>
	T BitsConvertion(U ConvData)
	{
		static_assert(std::alignment_of_v<T> == std::alignment_of_v<U>, "size of T is no matching for that U.");

		constexpr size_t dataSize = std::alignment_of_v<T>;

		T returnValue;
		memcpy(&returnValue, &ConvData, dataSize);

		return returnValue;
	}

	bool ParamsSendFlag = false;
	void ParamSendTable();
};

#endif
