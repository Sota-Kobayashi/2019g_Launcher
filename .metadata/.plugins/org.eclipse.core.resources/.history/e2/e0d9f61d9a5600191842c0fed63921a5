/*
 * signal.hpp
 *
 *  Created on: 2019/04/04
 *      Author: User
 */

#ifndef MYHEADERS_BOARD_IO_HPP_
#define MYHEADERS_BOARD_IO_HPP_

#include <type_traits>

#include <stm32f4xx.h>

enum class ioName : uint16_t
{
	sig0 = 0x0001,
	sig1 = 0x0002,
	sig2 = 0x0004,
	sig3 = 0x0008,
	sig4 = 0x0010,
	sig5 = 0x0020,
	sig6 = 0x0040,
	sig7 = 0x0080
};
enum class ioState { input, output };
enum class pinPullDirection{ no, up, down};

template
<ioName useIOname, ioState setIOstate, pinPullDirection setPinPuPd = pinPullDirection::no>
class IO_sigPins
{
public:
	IO_sigPins(){ GPIO_pinsInit(); }

	inline bool readNowState()
	{
		return GPIO_ReadInputDataBit(GPIOC, (uint16_t)useIOname);
	}

	inline void setNewState(const bool isPinHigh)
	{
		if(isPinHigh)	GPIO_SetBits(GPIOC, (uint16_t)useIOname);
		else			GPIO_ResetBits(GPIOC, (uint16_t)useIOname);
	}
	inline void pinToggle(){ GPIO_ToggleBits(GPIOC, (uint16_t)useIOname); }

private:
	void GPIO_pinsInit()
	{
		RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

		constexpr GPIO_InitTypeDef GPIO_insitStruct
		{
			(uint16_t)useIOname,

			setIOstate == ioState::input ? GPIO_Mode_IN : GPIO_Mode_OUT,

			GPIO_Speed_100MHz,

			GPIO_OType_PP,

			setPinPuPd == pinPullDirection::no ? GPIO_PuPd_NOPULL	:
			setPinPuPd == pinPullDirection::up ? GPIO_PuPd_UP		: GPIO_PuPd_DOWN
		};
		//GPIO_insitStruct.GPIO_Pin	= (uint16_t)useIOname;
		//GPIO_insitStruct.GPIO_Mode	= setIOstate == ioState::input ? GPIO_Mode_IN : GPIO_Mode_OUT;
		//GPIO_insitStruct.GPIO_PuPd	=
		//		setPinPuPd == pinPullDirection::no ? GPIO_PuPd_NOPULL	:
		//		setPinPuPd == pinPullDirection::up ? GPIO_PuPd_UP		: GPIO_PuPd_DOWN;
		//GPIO_insitStruct.GPIO_OType	= GPIO_OType_PP;
		//GPIO_insitStruct.GPIO_Speed	= GPIO_Speed_100MHz;
		GPIO_Init(GPIOC, &GPIO_insitStruct);
	}
};


#endif /* MYHEADERS_BOARD_IO_HPP_ */
