/*
 * rotary_encoder.h
 *
 *  Created on: 2019/03/01
 *      Author: User
 */

#ifndef MYHEADERS_ROTARY_ENCODER_H_
#define MYHEADERS_ROTARY_ENCODER_H_

#include <type_traits>

#include "stm32f4xx.h"
#include "stm32f4xx_conf.h"

class rotaryEncoder
{
public : enum class encoderName : uint8_t {RotEnc1, RotEnc2};
private:
	const encoderName useRotEncName_;
	TIM_TypeDef* const useTimer_;

public:
	rotaryEncoder() = delete;

	rotaryEncoder(const encoderName useRotEnc)
		: useRotEncName_(useRotEnc), useTimer_(useRotEnc == encoderName::RotEnc1 ? TIM3 : TIM2)
	{
		timerClockInit_();
		con
	}
	rotaryEncoder(const encoderName useRotEnc, const uint32_t setPeriod)
		: useRotEncName_(useRotEnc), useTimer_(useRotEnc == encoderName::RotEnc1 ? TIM3 : TIM2)
	{
		timerClockInit_();
		configEncoderInterfaceMode_(setPeriod);
	}

	template<typename T>
	std::enable_if_t<std::is_unsigned<T>::value, T> readCount()
	{
		return (T)useTimer_->CNT;
	}

	template<typename T>
	std::enable_if_t<std::is_signed<T>::value, T> readCount()
	{
		const T countValue = (T)useTimer_->CNT;
		std::make_unsigned_t<T> returnValue = 0;
	    if(countValue > (uint16_t)(useTimer_->ARR/2))
		{
			returnValue = returnValue - 1;
			returnValue = returnValue - (std::make_unsigned_t<T>)useTimer_->ARR;
			returnValue = returnValue + (std::make_unsigned_t<T>)countValue;
		}
		else
		{
			returnValue = (std::make_unsigned_t<T>)countValue;
		}
		return (T)returnValue;
	}

	virtual ~rotaryEncoder();

protected:
	inline void timerClockInit_()
	{
		const uint32_t RCC_Periph = (useRotEncName_ == encoderName::RotEnc1 ? RCC_APB1Periph_TIM3 : RCC_APB1Periph_TIM2);
		RCC_APB1PeriphClockCmd(RCC_Periph, ENABLE);
	}
	void configEncoderInterfaceMode_();
	inline void configEncoderInterfaceMode_(const uint32_t setPeriod)
	{
		TIM_SetAutoreload(useTimer_, setPeriod);
		configEncoderInterfaceMode_();
	}
	void configEncoderPins_timer2_();
	void configEncoderPins_timer3_();
	inline void configEncoderPins_()
	{
		if(useTimer_ == TIM2)configEncoderPins_timer2_();
		else configEncoderPins_timer3_();
	}
};



#endif /* MYHEADERS_ROTARY_ENCODER_H_ */
