
/**
  ******************************************************************************
  * @file    main.c
  * @author  Ac6
  * @version V1.0
  * @date    01-December-2013
  * @brief   Default main function.
  ******************************************************************************
*/
#define _DEFAULT_SOURCE
#define _USE_MATH_DEFINES
#include <cmath>
#include <string>

#include "stm32f4xx.h"
#include "stm32f4xx_conf.h"

#include <motor.hpp>
#include <electric_valve.hpp>
#include <led.hpp>
#include <rotary_encoder.hpp>
#include <uart.hpp>
#include <speed_pid.hpp>
#include <functional>
#include <vector>
#include <interrupt.hpp>

constexpr int gcc_version = __GNUC__ ;
constexpr int gcc_minorVersion = __GNUC_MINOR__;

void clockInit();

LED led;

class Launcher
{
public:
	Launcher() : launchMotorSpeedPID(encoderName::RotEnc1, motorPPR_, useGain_, 0.001)
	{
		launchMotorSpeedPID.setNewStateGate(MotorControl::gateEnableState::Enable);
		launchMotorSpeedPID.setCount((uint32_t)defaultEncoderCount);

		std::function<void(void)>& a = [&]{ this->update(); };
		systick::additionCallFunction( a );

		limitSensorPinsInit();
		EXTI0Intrrupt::init(0);

		EXTI0Intrrupt::additionCallFunction( [&]{ limitSensorIntrrupt(); } );

		launchMotorSpeedPID.setEnableState(true);
	}
	void update();
	const bool& isGotZeroPoint = isGotZeroPoint_;

	~Launcher();
private:
	enum class sequence : uint8_t
	{
		stop,
		launch,
		breaking
	};
	void throwingShagai();

	Speed_pid launchMotorSpeedPID;
	static constexpr PIDgain_speed useGain_ = {-0.0001, -0.0001, -0.0};
	static constexpr uint16_t motorPPR_ = 2048 * 4;

	static constexpr uint16_t defaultEncoderCount = 55000;
	static constexpr uint16_t encCount_stopPoint = 23000;

	/*members to get zero point*/
	static constexpr double getZeroPoint_motorDriveSpeed_ = -300;
	static constexpr double throwing_motorDriveSpeed_ = -55000;
	bool isGotZeroPoint_ = false;
	inline bool readLimitSensor(){ return (bool)GPIO_ReadInputDataBit(GPIOC, GPIO_Pin_0); }
	void limitSensorPinsInit();
	void getZeroPoint();
	void limitSensorIntrrupt();
};

int main(void)
{
	//clockInit();
	systick::init();

	Launcher launcher;

	while(true);
	return 0;
}

void clockInit()
{
	/*
	 * PLLM = 16, PLLN = 168, PLLP = 2, PLLQ = 8
	 * HSI clock is 16MHz. This is constant value.
	 * Expression of System clock is	: HSI x PLLN / (PLLM x PLLP) = 84MHz
	 * Expression of HCLK clock is		: SystemClock / HCLK_prescaler = 84MHz
	 * Expression of PCLK1 clock is		: HCLK / PCLK1_prescaler = 42MHz
	 * Expression of PCLK2 clock is		: HCLK / PCLK2_prescaler = 84MHz
	 */
	RCC_DeInit();

	FLASH_SetLatency(FLASH_Latency_2);

	RCC_HCLKConfig(RCC_SYSCLK_Div1);					// HCLK prescaler is 1.

	RCC_PCLK1Config(RCC_HCLK_Div2);						// PCLK1 prescaler is 2.
	RCC_PCLK2Config(RCC_HCLK_Div1);						// PCLK2 prescaler is 1.

	RCC_PLLCmd(DISABLE);
	RCC_PLLConfig(RCC_PLLSource_HSI, 16, 168, 2, 8);
	RCC_PLLCmd(ENABLE);
	while(RCC_GetFlagStatus(RCC_FLAG_PLLRDY) == RESET)

	RCC_SYSCLKConfig(RCC_SYSCLKSource_PLLCLK);

	while(RCC_GetSYSCLKSource() != 0x08);
}

void Launcher::throwingShagai()
{
	static sequence nowSequence = sequence::launch;
	switch(nowSequence)
	{
	case sequence::launch:
		if(launchMotorSpeedPID.readPositionCount<uint16_t>() < encCount_stopPoint)
		{
			launchMotorSpeedPID.setEnableState(false);
			nowSequence = sequence::breaking;
		}
		else
		{
			launchMotorSpeedPID.setEnableState(true);
			launchMotorSpeedPID.setTargetSpeed(throwing_motorDriveSpeed_);
		}
		break;

	case sequence::breaking:
		if(launchMotorSpeedPID.readPositionCount<uint16_t>() > encCount_stopPoint + 1000)nowSequence = sequence::stop;
		else launchMotorSpeedPID.MotorControl::setSpeed(-30);
		break;

	case sequence::stop:
		launchMotorSpeedPID.setSpeed(0);
		break;
	}
}

void Launcher::update()
{
	getZeroPoint();
	static int count = 0;
	if(count > 1000)
	{
		throwingShagai();
	}
	else if(isGotZeroPoint)
	{
		count++;
	}
	//throwingShagai();
	launchMotorSpeedPID.speedPID_update();

	std::string a = std::to_string(launchMotorSpeedPID.readPositionCount<uint16_t>()) + '\n';
	uart1.TransmitData(a);
}

void Launcher::getZeroPoint()
{
	if(!isGotZeroPoint)
	{
		launchMotorSpeedPID.setEnableState(true);
		if(readLimitSensor())
		{
			launchMotorSpeedPID.setTargetSpeed(getZeroPoint_motorDriveSpeed_);
		}
		else
		{
			launchMotorSpeedPID.setTargetSpeed(-1.0*getZeroPoint_motorDriveSpeed_);
		}
	}
	if(readLimitSensor())
	{
		led.setNewState(LED::ledColor::Red, LED::state::ON);
	}
	else
	{
		led.setNewState(LED::ledColor::Red, LED::state::OFF);
	}
}

void Launcher::limitSensorPinsInit()
{
	RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

	GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.GPIO_Pin	= GPIO_Pin_0;
	GPIO_InitStruct.GPIO_Mode	= GPIO_Mode_IN;
	GPIO_InitStruct.GPIO_PuPd	= GPIO_PuPd_NOPULL;
	GPIO_InitStruct.GPIO_Speed	= GPIO_Speed_2MHz;
	GPIO_Init(GPIOC, &GPIO_InitStruct);

}

void Launcher::limitSensorIntrrupt()
{
	led.setNewState(LED::ledColor::Yellow, LED::state::OFF);
	if(!isGotZeroPoint)
	{
		isGotZeroPoint_ = true;
		launchMotorSpeedPID.setPositionCount(defaultEncoderCount);
		launchMotorSpeedPID.setTargetSpeed(0.0);
		launchMotorSpeedPID.setEnableState(false);
		launchMotorSpeedPID.MotorControl::setSpeed(0);
	}
}


